#region License
// 
// Author: Joe McLain <nmp.developer@outlook.com>
// Copyright (c) 2013, Joe McLain and Digital Writing
// 
// Licensed under Eclipse Public License, Version 1.0 (EPL-1.0)
// See the file LICENSE.txt for details.
// 
#endregion
#if !NET35
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;

using System.Web.Razor;
using System.Web.Razor.Generator;

using System.Dynamic;

using RazorHosting;
using NmpBase;

namespace Nmp {
	// @RazorOnly
	// @RazorBefore
	// @Razor
	// @RazorAfter

	// @[ razor ] - macro is razorized (before divert)

	/*

		Need to add:


		@RazorAssembly at top of file

			must be full path if not in GAC

			will get: 
				
				Razor failed to compile the generated source.	

			if not found, this err returned for other errors as well


		#razorAddAssembly

		#razorAddUsing

		#razorAddContextItem


		Doc notes:

			(#block ...)'s are not processed by the macro processor

			use "macro(...l)@[razor]" to process blocks that have been scanned






	*/

			

	/////////////////////////////////////////////////////////////////////////////

	class RazorRunner {

		static List<string> DefaultNamespaces = new List<string>() { "Nmp", "NmpBase" };

		IMacroProcessor	mp;
		NmpStringList		assemblyPaths;

		RazorTemplateBase	lastInstance;


		/////////////////////////////////////////////////////////////////////////////

		public void MacroFromLastInstance( string macroName )
		{
			//
			// make a macro out of the last instance of the razor generated class
			// using 'macroName'
			//

			if( null != lastInstance ) {
				mp.AddObjectMacro( macroName, lastInstance );
			}
		}


		/////////////////////////////////////////////////////////////////////////////

		protected void AddHelpers( RazorTemplateBase templateBase )
		{
		
		//
		// could probably use ETB.CreateMethodInvoker() here
		//

		//
		// methods generated by razor in class that we're adding to NMP in case
		// NMP runs after
		//
		 
			MethodInfo [] methods = templateBase.GetType().GetMethods();
			foreach( var method in methods ) {
				if( typeof(HelperResult) == method.ReturnParameter.ParameterType ) {
					var objInfo = new ObjectInfo( templateBase, method.Name );
					if( objInfo.IsMethod ) {
						mp.AddObjectMacro( method.Name, new MethodInvoker(objInfo) );
					}
				}
			}

			return;
		}


		/////////////////////////////////////////////////////////////////////////////

		protected void CreateHostHandler( RazorEngineHost host )
		{
			host.GeneratedClassContext = new GeneratedClassContext(

					"Execute",										// executeMethodName

					"Write",											// writeMethoName

					"WriteLiteral",								// writeLiteralMethodName

					"HelperResult.Write",					// string writeToMethodName,

					"HelperResult.WriteLiteral",	// string writeLiteralToMethodName,

					"HelperResult",								// string templateTypeName;

					"DefineSection"								// string defineSectionMethodName
				);
		}


		/////////////////////////////////////////////////////////////////////////////

		protected void PrePostRenderHandler( bool calledBefore, RazorTemplateBase templateBase ) 
		{
			// ******
			var tBase = templateBase as NmpRazorTemplateBase;

			// ******
			if( calledBefore ) {
				tBase.mp = mp;
			}
			else {
				lastInstance = templateBase;
				AddHelpers( templateBase );
			}

			// ******
			return;
		}

		/////////////////////////////////////////////////////////////////////////////

		private string Runner( string text, bool returnSource, RazorRunnerException.RunHow runContext )
		{
			// ******
			//dynamic context = new ExpandoObject();
			//context.Version = 2.0;

			// ******
			var asmId = string.Empty;
			var result = string.Empty;
			var reader = new StringReader( text );

			// ******

//	as arguments to ctor pass the PrePostHandler() and a method to customize
//	the host and whatever else
//			 
//	 for the host we set the names for section, etc

			var razor = new RazorEngine<NmpRazorTemplateBase>( DefaultNamespaces, PrePostRenderHandler, CreateHostHandler );
			razor.SetError();

			try {
				asmId = razor.ParseAndCompileTemplate( assemblyPaths, reader );
			}
			catch ( Exception ex ) {
				ThreadContext.MacroError( "error Parsing and Compiling Razor template: {0}", ex.Message );
			}
			if( null == asmId ) {
				//
				// error 
				//
				const string ErrMsg = "Razor failed to compile the generated source.";
				throw new RazorRunnerException( runContext, ErrMsg, razor.ErrorMessage, razor.LastGeneratedCode );
			}

			// ******
			try {
				result = razor.RenderTemplateFromAssembly( asmId, null );
			}
			catch ( Exception ex ) {
				ThreadContext.MacroError( "error Rendering Razor Template from Assembly template: {0}", ex.Message );
			}
			if( null == result ) {
				const string ErrMsg = "Razor failed to execute the template.";
				throw new RazorRunnerException( runContext, ErrMsg, razor.ErrorMessage, razor.LastGeneratedCode );
			}

			// ******
			if( RazorRunnerException.RunHow.Run == runContext ) {
				//
				// (#block `razor'
				//
			}
			
			// ******
			return FileReader.FixText( returnSource ? RazorRunnerException.AddLineNumbers(razor.LastGeneratedCode) : result );
		}


		/////////////////////////////////////////////////////////////////////////////

		public string Run( string text )
		{
			return Runner( text, false, RazorRunnerException.RunHow.Run );
		}


		/////////////////////////////////////////////////////////////////////////////

		public string RunOnly( string text, bool returnSource )
		{
			return Runner( text, returnSource, RazorRunnerException.RunHow.RunOnly );
		}


		/////////////////////////////////////////////////////////////////////////////

		public string RunBefore( string text, bool returnSource )
		{
			return Runner( text, returnSource, RazorRunnerException.RunHow.RunBefore );
		}


		/////////////////////////////////////////////////////////////////////////////

		public string RunAfter( string text, bool returnSource )
		{
			return Runner( text, returnSource, RazorRunnerException.RunHow.RunAfter );
		}


		/////////////////////////////////////////////////////////////////////////////

		public RazorRunner( IMacroProcessor mp )
		{
			// ******
			this.mp = mp;
			this.assemblyPaths = ThreadContext.RazorAssemblyPaths;

			// ******
			string codeBase = LibInfo.CodeBase;
			if( ! assemblyPaths.Contains(codeBase) ) {
				assemblyPaths.Add( codeBase );
			}

			codeBase = string.Format( "{0}\\Nmp.dll", Path.GetDirectoryName(codeBase) );
			if( ! assemblyPaths.Contains(codeBase) ) {
				assemblyPaths.Add( codeBase );
			}
		}


		/////////////////////////////////////////////////////////////////////////////

		public static void AddAssemblies( IList<string> paths )
		{
			// ******
			var assemblyPaths = ThreadContext.RazorAssemblyPaths;

			foreach( var path in paths ) {
				string p = path.Trim();

				if( ! string.IsNullOrEmpty(p) ) {
					if( ! File.Exists(p) ) {
						ThreadContext.MacroWarning( "#razorAddAssemgly could not locate the file: \"{0}\"", p );
					}

					// ******
					assemblyPaths.Add( p );
				}
				else {
					ThreadContext.MacroWarning( "empty path name passed to #razorAddAssemgly()" );
				}
			}
		}

	}


}
#endif